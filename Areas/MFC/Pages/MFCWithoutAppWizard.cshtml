@page
@model sswa.Areas.MFC.Pages.MFCWithoutAppWizardModel
@{
	ViewData["Title"] = "Creating an MFC Application Without the AppWizard";
}

<div class="text-center">
<h1 class="display-4">@ViewData["Title"]</h1>
</div>

<p>This will describe how to create an MFC application without using the 
AppWizard. I do not recommend doing this always of course but I think this can 
be a useful alternative to using a dialog-based application. People often use 
dialog-based MFC applications when they do not want all the complications of the 
&quot;MFC Document/View Architecture&quot; yet dialogs have limitations. So in those 
situations that you want the simplicity of a dialog yet you want the 
conveniences of a real window you might want to use this solution. You can use 
the AppWizard to generate a SDI application and yank out and/or override parts 
you do not need so it is more a matter of personal preference.</p>
<p>There are some MFC experts that would say you are foolish to not use the 
AppWizard to generate a MFC project initially, as if MFC was designed to only be 
used in a project generated by the AppWizard. I learned MFC beginning with the 
first version when the AppWizard was not as powerful as it is now (as if it is really 
powerful now). I know that there was definitely MFC documentation showing how to 
make a simple MFC program with only about a dozen lines. It is relatively easy to create a small program that uses MFC 
without using the AppWizard; the only trick is that it is practically a 
necessity to have a resource file. Assuming we are not making an application 
that just has a modal dialog box, then we <b>must</b> have menu and string table 
resources. Initially our small applications will only have a plain CFrameWnd 
window without any overrides or handlers or anything like that but I will show 
how to add a view.</p>
<p>The following explains how to Create an MFC application without the AppWizard 
<b>and with ClassWizard support</b>.</p>
<h2>The Project</h2>
<p>To create the project:</p>
<ul>
  <li>Use the &quot;File | New&quot; menu as usual for creating projects</li>
  <li>In the template tree on the left, select &quot;Visual C++&quot; | &quot;Win32&quot;</li>
  <li>Create a &quot;Win32 Project&quot;</li>
  <li>Use whatever name you wish to for the project; I am using &quot;WithoutWizard&quot;</li>
    <li>In the &quot;Application Settings&quot; page select the checkbox for &quot;Empty project&quot;</li>
</ul>
<p>When the project has been created, in the Project Settings, on the &quot;General&quot; 
tab, change &quot;Use of MFC&quot; from saying not to use MFC to saying to <strong>Use MFC</strong> (for all configurations). You can choose to use MFC in either a static or dynamic libraries but of course we usually use dynamic libraries.</p>
    <p>Create a &quot;targetver.h&quot; file with the following contents:</p>
<pre>#pragma once
#include &lt;SDKDDKVer.h&gt;</pre>
    <h2>Precompiled Headers</h2>
<p>Now we create the header and implementation files for Precompiled Headers. I am using the
standard filenames stdafx.h and stdafx.cpp to ensure use of the ClassWizard,
although I am not sure how important that is. At least it allows use of
precompiled headers in a standard manner, right?</p>
<ol>
  <li>Create the stdafx.h header file with the following:
  <pre>#pragma once

#define VC_EXTRALEAN
#include &lt;afxwin.h&gt;
#include &lt;afxext.h&gt;</pre></li>
  <li>Create the stdafx.cpp file with the following:
  <pre>#include &quot;stdafx.h&quot;</pre></li>
</ol>
<p>Then:</p>
    <ul>
        <li>in the project&#39;s properties for &quot;C/C++&quot; | &quot;Precompiled Headers&quot; set &quot;Precompiled Header&quot; to &quot;Use (/Yu)&quot;</li>
        <li>in the properties for the stdafx.cpp file set &quot;Precompiled Header&quot; to &quot;Create (/Yc)&quot; <strong>for just that file</strong></li>
    </ul>
<h2>The Resource File</h2>
<p>There are a few requirements for the resource file. The menu can have anything in it; the requirement is that the resource Id for 
the menu <b>must</b> be IDR_MAINFRAME. The string table can have only one string 
in it and that string should have a resource Id also of IDR_MAINFRAME. The 
string is used by CWinApp for the application's title, such as the application&#39;s default title in message boxes.</p>
<p>To create a Resource file, in the Solution Explorer right-click on the &quot;Resource Files&quot; node and select &quot;Add&quot; | &quot;Resource...&quot;. Then press &quot;Cancel&quot; in the &quot;Add Resource&quot; dialog. Double-click the new file and then the file will be shown in a &quot;Resource View&quot;. In &quot;Resource View&quot; right-click the new file and select &quot;Resource Includes&quot;. For &quot;Read-only symbol directives&quot; remove the #include for &quot;winres.h&quot; and use the following instead:</p>
    <pre>#ifndef APSTUDIO_INVOKED
#include "targetver.h"
#endif
#include "afxres.h"
#include "verrsrc.h"
</pre>
<p>For &quot;Compile-time directives&quot; use the following:</p>
<pre>#define _AFX_NO_OLE_RESOURCES
#define _AFX_NO_TRACKER_RESOURCES
#define _AFX_NO_PROPERTY_RESOURCES

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
LANGUAGE 9, 1
#include "afxres.rc"      // Standard components
#endif
</pre>
    <p>Click &quot;OK&quot;. You will get a warning; click &quot;OK&quot; for it.</p>
    <p>Then in the Solution Explorer, edit the &quot;resource.h&quot; file (there might be one or two message boxes asking to close other files) and <strong>before</strong> the following line:</p>
    <pre>// Next default values for new objects</pre>
    <p>
        Add:</p>
    <pre>#define IDR_MAINFRAME 128</pre>
<p>Again in the Solution Explorer, right-click the resources (rc) file and select &quot;Open With...&quot;
    then select &quot;C++ Source Code Editor&quot;; if it asks to close it then select &quot;OK&quot;.
        Find the following lines near the bottom:
    </p>
<pre>#endif    // APSTUDIO_INVOKED

#endif    // English (United States) resources
/////////////////////////////////////////////////////////////////////////////

#ifndef APSTUDIO_INVOKED</pre>
<p>Add the following lines <strong>before</strong> the line &quot;#ifndef APSTUDIO_INVOKED&quot;:</p>
<pre>/////////////////////////////////////////////////////////////////////////////
//
// Menu
//

IDR_MAINFRAME MENU
BEGIN
	POPUP "&File"
	BEGIN
	MENUITEM "E&xit", ID_APP_EXIT
	END
END

/////////////////////////////////////////////////////////////////////////////
//
// String Table
//

STRINGTABLE
BEGIN
IDR_MAINFRAME           &quot;{Caption for your main window}&quot;
AFX_IDS_APP_TITLE       &quot;{Your application&#39;s title}&quot;
ID_APP_EXIT             "Quit the application; prompts to save documents\nExit"
END</pre>
    <p>
        Except specify an approriate value for IDR_MAINFRAME and AFX_IDS_APP_TITLE.
        Save and close that.</p>
<h2>Creating the Header and Implementation Files</h2>
    <p>
        Create the header file for your program. Assuming the project is named
    &quot;WithoutWizard&quot;, the header file would be &quot;WithoutWizard.h&quot;. Put the
    following in it:
    </p>
    <pre>#pragma once

class CWithoutWizardApp : public CWinApp {
public:
	CWithoutWizardApp() {};

// Overrides
// ClassWizard generated virtual function overrides
//{{AFX_VIRTUAL(CWithoutWizardApp)
public:
//}}AFX_VIRTUAL

// Implementation

//{{AFX_MSG(CWithoutWizardApp)
//}}AFX_MSG
DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}</pre>
    <p>
        Create the main cpp file for your program. Assuming the project is named
    &quot;WithoutWizard&quot;, the cpp file would be &quot;WithoutWizard.cpp&quot;. Put the
    following in it:</p>
    <pre>#include &quot;stdafx.h&quot;
#include &quot;resource.h&quot;
#include &quot;WithoutWizard.h&quot;

BEGIN_MESSAGE_MAP(CWithoutWizardApp, CWinApp)
//{{AFX_MSG_MAP(CWithoutWizardApp)
//}}AFX_MSG
END_MESSAGE_MAP()

CWithoutWizardApp WithoutWizardApp;</pre>
<h2>Override InitInstance</h2>
<p>Notice that we do not have even an InitInstance for our 
application. We are ready to use the ClassWizard and create an InitInstance for the application.</p>
<p>Save all unsaved files in the project.
Then right-click the solution in the Solution Explorer and select &quot;Class Wizard...&quot;. Then in the ClassWizard select your project from the Project drop-down if it is not yet selected. Add an override for InitInstance in the &quot;Virtual Functions&quot; tab for your
application by clicking &quot;Add Function&quot;.</p>
    
<h2>Frame Window</h2>

<p>You can use the ClassWizard to add a class (such as CMainFrame) derived from CFrameWnd and use that class for your frame, so you can
customize the window as needed. For me, however, ClassWizard always says that CMainFrame already exists. I don&#39;t know why. So I use a slightly different name and then rename the files and the class.</p>
    <p>Assuming you will not be using dynamic creation, change the DECLARE_DYNCREATE macro in the header to
    DECLARE_DYNAMIC and make the default constructor public. Correspondingly in the implementation file change the IMPLEMENT_DYNCREATE macro to IMPLEMENT_DYNAMIC.</p>
    <h2>Finishing the Application</h2>
<p>Use the following in the InitInstance:</p>
<pre>SetRegistryKey(_T("Local AppWizard-Generated Applications"));
LoadStdProfileSettings(8); // Load standard INI file options (including MRU)
CMainFrame* pFrame = new CMainFrame;
if (!pFrame)
	return FALSE;
m_pMainWnd = pFrame;
if (!pFrame->LoadFrame(IDR_MAINFRAME)) {
	AfxMessageBox(_T("Frame not created"));
	return FALSE;
}
pFrame->ShowWindow(m_nCmdShow);
pFrame->UpdateWindow();
return CWinApp::InitInstance();</pre>
<p>Build the project and test it. This will provide a minimal application that 
    can be used for many things. The application would probably be especially 
useful if you only needed to use GDI with the window.</p>
<p>See <a href="https://msdn.microsoft.com/en-us/library/xkh1wxd8.aspx">How to: Create Project Templates</a>. This might be a good place to create a Project Template based on the project we have built.</p>

<h2>Making a View</h2>

<p>Since we are using CFrameWnd::LoadFrame to create a frame window, it is quite 
easy to add a view. First derive a class from a view. Then specify the derived class in an instance of <span class="op">CCreateContext,
then pass that to </span>LoadFrame.  <span class="l">So your </span>InitInstance could be something like:</p>

<pre><span class="l">BOOL CWithoutWizardApp::InitInstance() {
</span>SetRegistryKey(_T(&quot;Local AppWizard-Generated Applications&quot;));
LoadStdProfileSettings(8);	// Load standard INI file options (including MRU)

<span class="l">CFrameWnd *pFrameWnd;
pFrameWnd = new CFrameWnd;
if(!pFrameWnd) {
	AfxMessageBox(_T(&quot;Window not made&quot;));
	return FALSE;
	}
CCreateContext CreateContext;
CreateContext.m_pNewViewClass = RUNTIME_CLASS(CWithoutWizardView);
CreateContext.m_pCurrentFrame = pFrameWnd;
if (!pFrameWnd-&gt;LoadFrame(IDR_MAINFRAME, WS_OVERLAPPEDWINDOW | WS_VISIBLE,
		NULL, &amp;CreateContext)) {
	AfxMessageBox(_T(&quot;Frame Load Error&quot;));
	return FALSE;
	}
m_pMainWnd = pFrameWnd;
pFrameWnd-&gt;InitialUpdateFrame(NULL, TRUE);</span>	<span class="l">// Will do ShowWindow
return CWinApp::InitInstance();
}</span></pre>
    <h2>Additional Notes</h2>
<p>I have summarized what <a href="LoadFrame/index.php">CFrameWnd::LoadFrame</a> 
does in case that helps.</p>
<p>Also, I am not sure if it would work to use CWnd::Create to create a plain 
window instead of using <a href="LoadFrame/index.php">CFrameWnd::LoadFrame</a> 
and getting a frame window. I tried but could not get it to work. It is easy 
enough to try but until I do let me just say that one thing that is important is 
that the main window object must be allocated in the heap (with &quot;new&quot;). That is 
because MFC will destroy the main window for you and will use &quot;delete&quot; for the 
object. It does this for the object that m_pMainWnd points to. If m_pMainWnd&nbsp; 
is NULL then InitInstance will exit the application, so it does not work to do 
that.</p>
<p>Since we are operating with a stripped-down MFC we are missing a few 
conveniences. One problem is: where is the view? How can the applicaton class 
communicate with the view? The following is one way for the application to find 
the view:</p>
<pre>CView * CWithoutWizardApp::FindView() {
	const CString ClassName(&quot;CWithoutWizardView&quot;);
	CRuntimeClass* pRuntimeClass;
	CWnd* pWnd=NULL;
pWnd = m_pMainWnd-&gt;GetDescendantWindow(AFX_IDW_PANE_FIRST);
if (!pWnd)
	return NULL;
pRuntimeClass = pWnd-&gt;GetRuntimeClass();
if (pRuntimeClass-&gt;m_lpszClassName == ClassName)
	return (CView *)pWnd;
return NULL;
}</pre>
<p>Notice that using CRuntimeClass to check the class is not necessary and could 
be removed; at least it is not necessary for a release build. So FindView can be 
used as in the following:</p>
<pre>pWithoutWizardView = (CWithoutWizardView*)FindView();
if (pWithoutWizardView) {
	pWithoutWizardView-&gt;OnUpdate(NULL, 1, &amp;MessageText);
}</pre>
<p>To use OnUpdate in that manner, use the following in your view class:</p>
<pre>friend class CWithoutWizardApp;</pre>
